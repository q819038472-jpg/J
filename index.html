<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Super Scouter XR</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }

        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 10, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; color: #fff;
        }

        button {
            padding: 15px 40px; font-size: 20px; 
            color: #000; background: #fff; border: 2px solid #fff; 
            border-radius: 30px; font-weight: bold; cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 15px #fff;
        }

        #hud-status {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: #fff; font-size: 18px; pointer-events: none; 
            text-shadow: 0 0 5px #000; display: none; letter-spacing: 2px;
        }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="launcher">
    <h1 style="text-shadow: 0 0 10px #0f0;">SCOUTER SYSTEM v2.0</h1>
    <div style="border:1px solid #666; padding:20px; border-radius:10px; background:rgba(0,0,0,0.5)">
        <p>ğŸ‘‰ <b>RIGHT HAND POINT</b>: Scan Target</p>
        <p>âœŠ <b>LEFT HAND FIST</b>: Reset</p>
    </div>
    <button id="btn-start">ACTIVATE HUD</button>
</div>

<div id="hud-status">SYSTEM ONLINE</div>

<script type="module">
    import * as THREE from 'three';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let handLeft, handRight;

    // ç‰©ä½“å¯¹è±¡
    let cursorTriangle; // å¯åŠ¨æ—¶çš„ç™½è‰²ä¸‰è§’
    let targetGroup;    // åŒ…å«è½®å»“ã€æŒ‡é’ˆçš„ç»„
    let powerSprite;    // æˆ˜æ–—åŠ›UI

    // é€»è¾‘æ§åˆ¶
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let isLocked = false;
    let scanInterval = null;
    let scanLineY = 0; // UIæ‰«æçº¿ä½ç½®

    // Canvas ç”¨äºç»˜åˆ¶é…·ç‚«UI
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;

    document.getElementById('btn-start').addEventListener('click', initAR);

    async function initAR() {
        if (!navigator.xr) return alert("WebXR unsupported");
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['hand-tracking', 'dom-overlay'],
            domOverlay: { root: document.body }
        });
        document.getElementById('launcher').style.display = 'none';
        document.getElementById('hud-status').style.display = 'block';
        initScene(session);
    }

    function initScene(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        session.addEventListener('end', () => location.reload());

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0, 5, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- 1. å¯åŠ¨æ—¶å…‰æ ‡ (ç™½è‰²å®å¿ƒä¸‰è§’å½¢) ---
        // RingGeometry å‚æ•°: innerRadius, outerRadius, thetaSegments (3=ä¸‰è§’å½¢)
        const cursorGeo = new THREE.RingGeometry(0.02, 0.06, 3); 
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        cursorTriangle = new THREE.Mesh(cursorGeo, cursorMat);
        cursorTriangle.rotation.x = -Math.PI / 2; // å¹³èºº
        cursorTriangle.rotation.z = -Math.PI / 2; // å°–å¤´æœå‰
        cursorTriangle.visible = false;
        scene.add(cursorTriangle);

        // --- 2. ç›®æ ‡é”å®šç»„åˆåŒ… (è½®å»“ + æŒ‡é’ˆ) ---
        createTargetVisuals();

        // --- 3. æ‰‹åŠ¿ ---
        setupHands();

        renderer.setAnimationLoop(render);
    }

    function createTargetVisuals() {
        targetGroup = new THREE.Group();
        targetGroup.visible = false;
        scene.add(targetGroup);

        // A. ç™½è‰²è½®å»“ (èƒ¶å›Šä½“ Wireframe) - æ¨¡æ‹Ÿäººçš„å¤–å½¢
        const capsuleGeo = new THREE.CapsuleGeometry(0.35, 1.0, 4, 8);
        const capsuleMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.4 
        });
        const bodyOutline = new THREE.Mesh(capsuleGeo, capsuleMat);
        bodyOutline.position.y = 0.85; // èƒ¶å›Šä¸­å¿ƒä¸Šç§»ï¼Œåº•è¾¹è´´åœ°
        targetGroup.add(bodyOutline);

        // B. å·¦å³æŒ‡å‘çš„ä¸‰è§’å½¢
        const pointerGeo = new THREE.ConeGeometry(0.1, 0.2, 3); // é”¥ä½“çœ‹èµ·æ¥æ›´åƒç®­å¤´
        const pointerMat = new THREE.MeshNormalMaterial({ wireframe: false }); // ä½¿ç”¨æ³•çº¿æè´¨æ˜¾å¾—æœ‰ç§‘æŠ€æ„Ÿ

        // å·¦ç®­å¤´ (æŒ‡å‘å³)
        const leftPtr = new THREE.Mesh(pointerGeo, pointerMat);
        leftPtr.position.set(-0.7, 1.0, 0); // äººç‰©å·¦ä¾§
        leftPtr.rotation.z = -Math.PI / 2;
        leftPtr.name = "leftPtr";
        targetGroup.add(leftPtr);

        // å³ç®­å¤´ (æŒ‡å‘å·¦)
        const rightPtr = new THREE.Mesh(pointerGeo, pointerMat);
        rightPtr.position.set(0.7, 1.0, 0); // äººç‰©å³ä¾§
        rightPtr.rotation.z = Math.PI / 2;
        rightPtr.name = "rightPtr";
        targetGroup.add(rightPtr);
    }

    function setupHands() {
        const handModelFactory = new XRHandModelFactory();
        function buildHand(idx) {
            const hand = renderer.xr.getHand(idx);
            hand.add(handModelFactory.createHandModel(hand, "mesh"));

            // æ”¹å˜æ‰‹éƒ¨æè´¨ä¸ºç™½è‰²ç§‘æŠ€ç½‘æ ¼
            hand.addEventListener('connected', () => {
                hand.traverse(child => {
                    if(child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xccffcc, wireframe: true, transparent: true, opacity: 0.3
                        });
                    }
                });
            });
            scene.add(hand);
            return hand;
        }
        handLeft = buildHand(0);
        handRight = buildHand(1);
    }

    // --- é…·ç‚« UI ç»˜åˆ¶æ ¸å¿ƒ ---
    function updateCanvasUI(powerValue, label, isFinal) {
        // 1. å…³é”®ï¼šæ¸…é™¤ä¸Šä¸€å¸§ï¼Œé˜²æ­¢é‡å ï¼
        ctx.clearRect(0, 0, 512, 256);

        // 2. ç»˜åˆ¶åŠé€æ˜ç§‘æŠ€åº•æ¿
        ctx.fillStyle = "rgba(0, 20, 0, 0.7)";
        ctx.beginPath();
        ctx.moveTo(20, 0); ctx.lineTo(492, 0); ctx.lineTo(512, 20);
        ctx.lineTo(512, 256); ctx.lineTo(20, 256); ctx.lineTo(0, 236); ctx.lineTo(0, 0);
        ctx.fill();

        // 3. ç»˜åˆ¶è¾¹æ¡†
        ctx.strokeStyle = isFinal && powerValue > 8000 ? "#ff3333" : "#00ff88";
        ctx.lineWidth = 4;
        ctx.stroke();

        // 4. ç½‘æ ¼èƒŒæ™¯
        ctx.strokeStyle = "rgba(0, 255, 100, 0.1)";
        ctx.lineWidth = 1;
        for(let i=0; i<512; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,256); ctx.stroke(); }
        for(let i=0; i<256; i+=40) { ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(512,i); ctx.stroke(); }

        // 5. ç»˜åˆ¶æ–‡å­— (å¸¦å‘å…‰æ•ˆæœ)
        ctx.shadowBlur = 10;
        ctx.shadowColor = isFinal && powerValue > 8000 ? "#ff0000" : "#00ff00";

        // æˆ˜æ–—åŠ›æ•°å€¼
        ctx.font = "bold 110px Courier New"; // æ¢ä¸ªæ›´ç²—çš„å­—ä½“
        ctx.textAlign = "center";
        ctx.fillStyle = isFinal && powerValue > 8000 ? "#ff5555" : "#ccffcc";
        ctx.fillText(powerValue, 256, 140);

        // æ ‡ç­¾
        ctx.font = "30px Arial";
        ctx.fillStyle = "#ffffff";
        ctx.shadowBlur = 0;
        ctx.fillText(label, 256, 210);

        // 6. åŠ¨æ€æ‰«æçº¿
        scanLineY = (scanLineY + 5) % 256;
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
        ctx.fillRect(0, scanLineY, 512, 10);
    }

    // --- è§¦å‘é€»è¾‘ ---
    function triggerScan(position) {
        if (isLocked) return;
        isLocked = true;
        cursorTriangle.visible = false; // éšè—ä¸‰è§’å…‰æ ‡

        // 1. æ˜¾ç¤ºç›®æ ‡è½®å»“ç»„åˆ
        targetGroup.position.copy(position);

        // è®©è½®å»“æœå‘æ‘„åƒæœº (åªæ—‹è½¬Yè½´)
        targetGroup.lookAt(camera.position.x, targetGroup.position.y, camera.position.z);
        targetGroup.visible = true;

        // 2. åˆ›å»ºå¤´é¡¶ UI Sprite
        if (powerSprite) scene.remove(powerSprite);
        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        powerSprite = new THREE.Sprite(mat);
        powerSprite.scale.set(1.2, 0.6, 1);
        powerSprite.position.copy(position).add(new THREE.Vector3(0, 1.9, 0)); // åœ¨äººå¤´é¡¶ (çº¦1.9ç±³é«˜)
        scene.add(powerSprite);

        // 3. å¼€å§‹æ•°å€¼è·³åŠ¨
        let steps = 0;
        const targetVal = Math.floor(Math.random() * 8000) + 1000; // 1000~9000

        scanInterval = setInterval(() => {
            steps++;
            const rnd = Math.floor(Math.random() * 9999);
            updateCanvasUI(rnd, "- ANALYZING -", false);
            texture.needsUpdate = true; // é‡è¦ï¼šé€šçŸ¥çº¹ç†æ›´æ–°

            if (steps > 40) { // 2ç§’ååœæ­¢
                clearInterval(scanInterval);
                const finalVal = targetVal + (Math.random() > 0.8 ? 8000 : 0); // 20%å‡ ç‡çˆ†è¡¨
                const label = finalVal > 9000 ? "!! WARNING !!" : "POWER LEVEL";
                updateCanvasUI(finalVal, label, true);
                texture.needsUpdate = true;
            }
        }, 50);
    }

    function resetSystem() {
        isLocked = false;
        clearInterval(scanInterval);
        targetGroup.visible = false; // éšè—è½®å»“
        if (powerSprite) {
            scene.remove(powerSprite);
            powerSprite = null;
        }
        document.getElementById('hud-status').innerText = "SYSTEM READY";
    }

    // --- æ‰‹åŠ¿åˆ¤å®š ---
    function isPointing(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;

        // å®½æ¾åˆ¤å®šï¼šé£ŸæŒ‡ç¦»æ‰‹è…•è¿œï¼Œä¸­æŒ‡ç¦»æ‰‹è…•è¿‘
        return wrist.distanceTo(indexTip) > 0.10 && wrist.distanceTo(middleTip) < 0.10;
    }

    function isFist(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;
        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        // é£ŸæŒ‡æ”¶å›
        return wrist.distanceTo(indexTip) < 0.09;
    }

    // --- æ¸²æŸ“å¾ªç¯ ---
    function render(timestamp, frame) {
        if (frame) {
            const refSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            // Hit Test
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then(ref => {
                    session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source);
                });
                hitTestSourceRequested = true;
            }

            if (hitTestSource && !isLocked) {
                const hits = frame.getHitTestResults(hitTestSource);
                if (hits.length > 0) {
                    const pose = hits[0].getPose(refSpace);
                    cursorTriangle.visible = true;
                    cursorTriangle.matrix.fromArray(pose.transform.matrix);

                    // ä¿®æ­£ä¸‰è§’å½¢æ—‹è½¬ï¼šhitTestç»™å‡ºçš„æ˜¯å¹³é¢æ³•çº¿ï¼Œæˆ‘ä»¬éœ€è¦å¾®è°ƒè®©å®ƒæŒ‡ç€å‰æ–¹
                    // é»˜è®¤Ringæ˜¯å¹³èººçš„ï¼Œæˆ‘ä»¬ä¿æŒå®ƒå¹³èººè´´åœ°
                } else {
                    cursorTriangle.visible = false;
                }
            }

            // äº¤äº’
            if (!isLocked && cursorTriangle.visible && isPointing(handRight)) {
                const pos = new THREE.Vector3().setFromMatrixPosition(cursorTriangle.matrix);
                triggerScan(pos);
            }
            if (isLocked && isFist(handLeft)) {
                resetSystem();
            }

            // åŠ¨ç”»ï¼šå·¦å³æŒ‡é’ˆæµ®åŠ¨
            if (isLocked && targetGroup.visible) {
                const time = timestamp / 1000;
                const leftPtr = targetGroup.getObjectByName("leftPtr");
                const rightPtr = targetGroup.getObjectByName("rightPtr");
                if (leftPtr && rightPtr) {
                    leftPtr.position.x = -0.7 + Math.sin(time * 5) * 0.1; // å·¦å³æ‘†åŠ¨
                    rightPtr.position.x = 0.7 - Math.sin(time * 5) * 0.1;
                }
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>

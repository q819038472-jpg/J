<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR æè‡´ç”»è´¨ç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #000; color: white; font-family: sans-serif; overflow: hidden; }
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: linear-gradient(45deg, #111, #222); z-index: 10;
        }
        h1 { font-weight: 300; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 20px; }
        button {
            padding: 18px 45px; font-size: 20px; 
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            color: white; border: none; border-radius: 50px; 
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
            transition: transform 0.1s; cursor: pointer;
        }
        button:active { transform: scale(0.95); }
        p { color: #888; font-size: 14px; margin-top: 15px; }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="launcher">
    <h1>âœ¨ èƒ½é‡ç²’å­åœº</h1>
    <button id="btn-enter">åˆå§‹åŒ– AR ç©ºé—´</button>
    <p>ç©ºé—´å®šä½ | æŸ”å…‰ç²’å­ | æ‰‹åŠ¿äº¤äº’</p>
</div>

<script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let hand1, hand2;
    let particleSystem, particleGeo;
    let originalPositions = []; // åŸå§‹ä½ç½®
    let randomOffsets = [];     // éšæœºåç§»é‡ï¼ˆç”¨äºå‘¼å¸æ•ˆæœï¼‰

    // ç²’å­å‚æ•°
    const PARTICLE_COUNT = 2500;
    const PARTICLE_SIZE = 0.015; // ç²’å­å¤§å°
    const RADIUS = 0.3; // åˆå§‹çƒä½“åŠå¾„

    // ç©ºé—´å®¹å™¨
    let stage; 

    document.getElementById('btn-enter').addEventListener('click', onEnter);

    async function onEnter() {
        if (!navigator.xr) return alert("ä¸æ”¯æŒ WebXR");
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local'], 
                optionalFeatures: ['hand-tracking']
            });
            document.getElementById('launcher').style.display = 'none';
            initThree(session);
        } catch (e) {
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    }

    // --- åŠ¨æ€ç”ŸæˆæŸ”å…‰çº¹ç† (æ— éœ€åŠ è½½å›¾ç‰‡) ---
    function getSoftGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');

        // ç»˜åˆ¶å¾„å‘æ¸å˜
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   // ä¸­å¿ƒæäº®
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); // æ ¸å¿ƒå…‰æ™•
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); // å¤–éƒ¨æŸ”å…‰
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');           // è¾¹ç¼˜é€æ˜

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    function initThree(session) {
        scene = new THREE.Scene();
        scene.background = null;

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local'); // ä½¿ç”¨ local ç©ºé—´ï¼ŒåŸç‚¹åœ¨å¯åŠ¨æ—¶çš„å¤´éƒ¨ä½ç½®
        renderer.xr.setSession(session);

        session.addEventListener('end', () => {
            renderer.setAnimationLoop(null);
            document.getElementById('launcher').style.display = 'flex';
        });

        // --- åˆ›å»ºç©ºé—´èˆå° ---
        stage = new THREE.Group();
        // ã€å…³é”®ã€‘å›ºå®šåœ¨å¯åŠ¨æ—¶ä½ç½®çš„æ­£å‰æ–¹ 0.6 ç±³ï¼Œé«˜åº¦ç•¥ä½äºè§†çº¿
        stage.position.set(0, -0.2, -0.6); 
        scene.add(stage);

        // 1. åˆ›å»ºç²’å­ç³»ç»Ÿ
        createParticles();

        // 2. æ·»åŠ æ‰‹éƒ¨
        hand1 = renderer.xr.getHand(0); scene.add(hand1);
        hand2 = renderer.xr.getHand(1); scene.add(hand2);

        renderer.setAnimationLoop(render);
    }

    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        const color1 = new THREE.Color(0x00d2ff); // é’è“
        const color2 = new THREE.Color(0x9d00ff); // ç´«è‰²

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // çƒå½¢åˆ†å¸ƒç®—æ³•
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            // ç¨å¾®è®©å®ƒæ¾æ•£ä¸€ç‚¹ï¼Œä¸è¦å…¨æ˜¯å®å¿ƒ
            const r = Math.cbrt(Math.random()) * RADIUS;

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            positions.push(x, y, z);

            // ä¿å­˜åŸå§‹ä½ç½®ç”¨äºå¤åŸ
            originalPositions.push({x, y, z});
            // éšæœºç›¸ä½ï¼Œè®©æ¯ä¸ªç²’å­å‘¼å¸èŠ‚å¥ä¸ä¸€æ ·
            randomOffsets.push(Math.random() * 100);

            // éšæœºæ··åˆé¢œè‰²
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        particleGeo = geometry;

        // --- é«˜çº§æè´¨è®¾ç½® ---
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: getSoftGlowTexture(), // ä½¿ç”¨åŠ¨æ€ç”Ÿæˆçš„å…‰æ™•çº¹ç†
            vertexColors: true,        // å¯ç”¨é¡¶ç‚¹é¢œè‰²
            transparent: true,
            opacity: 0.9,
            // å…³é”®ï¼šAdditveBlending ä¼šè®©ç²’å­å åŠ å˜äº®ï¼Œä½†åœ¨æ˜äº®ARèƒŒæ™¯ä¸‹å¯èƒ½çœ‹ä¸æ¸…
            // æ—¢ç„¶æˆ‘ä»¬è¦â€œç»†è…»ä¸”ä¸å´©æºƒâ€ï¼Œä½¿ç”¨ NormalBlending é…åˆå‘å…‰è´´å›¾æ˜¯æœ€ç¨³å¦¥çš„
            // å¦‚æœèƒŒæ™¯å¾ˆé»‘ï¼ŒAdditive æ•ˆæœæ›´å¥½ï¼›å¦‚æœèƒŒæ™¯æ˜¯ç™½å¤©å®¤å†…ï¼ŒNormal æ›´å¥½ã€‚
            // è¿™é‡Œæˆ‘ä»¬ç”¨ Custom (Normal) ä½†å…³æ‰ depthWrite
            blending: THREE.NormalBlending, 
            depthWrite: false, // ç²’å­ä¹‹é—´ä¸é®æŒ¡ï¼Œçœ‹èµ·æ¥æ›´åƒä¸€å›¢äº‘
            depthTest: true
        });

        particleSystem = new THREE.Points(geometry, material);
        stage.add(particleSystem);
    }

    function getGesture(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist'] || !hand.joints['middle-finger-tip']) return 'neutral';
        const d = hand.joints['wrist'].position.distanceTo(hand.joints['middle-finger-tip'].position);
        if (d < 0.08) return 'fist';
        if (d > 0.12) return 'palm';
        return 'neutral';
    }

    // åŠ¨ç”»æ—¶é’Ÿ
    const clock = new THREE.Clock();

    function render() {
        const time = clock.getElapsedTime();

        // 1. æ£€æµ‹æ‰‹åŠ¿
        let gesture = 'neutral';
        const g1 = getGesture(hand1);
        const g2 = getGesture(hand2);
        if (g1 !== 'neutral' && g1 !== 'none') gesture = g1;
        else if (g2 !== 'neutral' && g2 !== 'none') gesture = g2;

        // 2. ç²’å­åŠ¨ç”»é€»è¾‘
        const positions = particleGeo.attributes.position.array;

        // ç›®æ ‡é¢œè‰² (ç”¨äºæ•´ä¸ªç²’å­å›¢å˜è‰²)
        let targetR=0, targetG=0, targetB=0; 
        // è¿™é‡Œåªæ˜¯ç®€å•çš„é€»è¾‘ï¼Œå¦‚æœè¦æ”¹å•ä¸ªç²’å­é¢œè‰²éœ€è¦æ“ä½œ color bufferï¼Œä¸ºæ€§èƒ½è€ƒè™‘æš‚ä¸”åªæ”¹å½¢æ€

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const ox = originalPositions[i].x;
            const oy = originalPositions[i].y;
            const oz = originalPositions[i].z;

            // --- å‘¼å¸æ•ˆæœ (Idle Animation) ---
            // è®©ç²’å­åœ¨åŸä½é™„è¿‘åšæ­£å¼¦æ³¢è¿åŠ¨
            const drift = Math.sin(time * 1.5 + randomOffsets[i]) * 0.02;

            let tx, ty, tz;

            if (gesture === 'palm') {
                // ğŸ’¥ çƒŸèŠ±æ¨¡å¼ï¼šå‘å¤–çˆ†ç‚¸ï¼Œå¹¶åŠ ä¸Šå¼ºçƒˆçš„éšæœºæŠ–åŠ¨
                // é¢œè‰²æˆ‘ä»¬é€šè¿‡ material.color å…¨å±€å åŠ 
                tx = ox * 3.5 + drift;
                ty = oy * 3.5 + drift;
                tz = oz * 3.5 + drift;
            } else if (gesture === 'fist') {
                // ğŸ›‘ èšåˆæ¨¡å¼ï¼šå¼ºåŠ›å‹ç¼©åˆ°ä¸­å¿ƒ
                tx = ox * 0.1;
                ty = oy * 0.1;
                tz = oz * 0.1;
            } else {
                // ğŸŒŠ é»˜è®¤æ¨¡å¼ï¼šå¤åŸ + å‘¼å¸
                tx = ox + drift;
                ty = oy + drift;
                tz = oz + drift;
            }

            // å¹³æ»‘æ’å€¼ (Lerp) - è®©è¿åŠ¨æœ‰â€œé˜»å°¼æ„Ÿâ€ï¼Œè€Œä¸æ˜¯ç¬é—´è·³å˜
            // 0.1 æ˜¯å¹³æ»‘ç³»æ•°ï¼Œè¶Šå°è¶Šæ…¢
            positions[ix]   += (tx - positions[ix]) * 0.08;
            positions[ix+1] += (ty - positions[ix+1]) * 0.08;
            positions[ix+2] += (tz - positions[ix+2]) * 0.08;
        }

        // å…¨å±€é¢œè‰²ä¿®æ­£
        if (gesture === 'palm') {
            particleSystem.material.color.setHex(0xffaa00); // æš–é‡‘
            particleSystem.material.opacity = 1.0;
        } else if (gesture === 'fist') {
            particleSystem.material.color.setHex(0xff0055); // ç‚½çº¢
            particleSystem.material.opacity = 0.8;
        } else {
            particleSystem.material.color.setHex(0xffffff); // æ¢å¤åŸæœ¬çš„è“ç´«æ¸å˜
            particleSystem.material.opacity = 0.9;
        }

        particleGeo.attributes.position.needsUpdate = true;

        // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªèˆå°ï¼Œå¢åŠ ç©ºé—´æ„Ÿ
        stage.rotation.y += 0.002;

        renderer.render(scene, camera);
    }
</script>
</body>
</html>

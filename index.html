<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR Scouter 3D</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }

        /* å¯åŠ¨ç•Œé¢ */
        #launcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 20, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999; color: #0f0;
        }

        .guide-box {
            border: 2px solid #0f0; padding: 20px; border-radius: 10px;
            background: rgba(0, 50, 0, 0.5); text-align: left;
            margin-bottom: 20px; max-width: 80%;
        }

        button {
            padding: 20px 50px; font-size: 24px; color: #000; background: #0f0;
            border: none; border-radius: 50px; font-weight: bold; cursor: pointer;
        }

        /* ç®€å•çš„ HUD çŠ¶æ€æ–‡å­—ï¼Œå›ºå®šåœ¨å±å¹•ä¸‹æ–¹ */
        #hud-status {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: #0f0; font-size: 20px; pointer-events: none; 
            text-shadow: 0 0 5px #000; display: none;
        }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="launcher">
    <h1>DRAGON BALL SCOUTER AR</h1>
    <div class="guide-box">
        <p>ğŸ‘‰ <b>RIGHT HAND POINT</b>: Lock Target & Scan (å³æ‰‹é£ŸæŒ‡æŒ‡å‘ç›®æ ‡)</p>
        <p>âœŠ <b>LEFT HAND FIST</b>: Reset System (å·¦æ‰‹æ¡æ‹³å¤ä½)</p>
        <p>â„¹ï¸ Ensure you can see the <b>Wireframe Hands</b>!</p>
    </div>
    <button id="btn-start">BOOT SYSTEM</button>
</div>

<div id="hud-status">SYSTEM READY. WAITING FOR INPUT...</div>

<script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let camera, scene, renderer;
    let handLeft, handRight;
    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    // æˆ˜æ–—åŠ›æ ‡ç­¾ (Sprite)
    let powerSprite = null; 
    let scanInterval = null;
    let isLocked = false;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 256;

    document.getElementById('btn-start').addEventListener('click', initAR);

    async function initAR() {
        if (!navigator.xr) return alert("WebXR unsupported");

        // å¯åŠ¨ Three.js
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['hand-tracking', 'dom-overlay'],
            domOverlay: { root: document.body }
        });

        document.getElementById('launcher').style.display = 'none';
        document.getElementById('hud-status').style.display = 'block';

        initScene(session);
    }

    function initScene(session) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);

        session.addEventListener('end', () => location.reload());

        // ç¯å…‰
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444));

        // --- 1. Reticle (ç„å‡†å…‰æ ‡) ---
        const reticleGeo = new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI/2);
        const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        reticle = new THREE.Mesh(reticleGeo, reticleMat);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // --- 2. æ‰‹åŠ¿æ˜¾ç¤º (å…³é”®æ”¹è¿›) ---
        const handModelFactory = new XRHandModelFactory();

        function createHand(index) {
            const hand = renderer.xr.getHand(index);
            // ä½¿ç”¨ "mesh" æ¨¡å¼ï¼Œè¿™æ ·ä½ èƒ½çœ‹åˆ°åƒæ‰‹å¥—ä¸€æ ·çš„3Dæ¨¡å‹
            const model = handModelFactory.createHandModel(hand, "mesh");

            // ä¿®æ”¹æè´¨ï¼Œè®©å®ƒçœ‹èµ·æ¥åƒé«˜ç§‘æŠ€å…¨æ¯æ‰‹å¥—
            hand.addEventListener('connected', (event) => {
               hand.traverse((child) => {
                   if(child.isMesh) {
                       child.material = new THREE.MeshBasicMaterial({ 
                           color: 0x00ffff, 
                           wireframe: true, 
                           transparent: true, 
                           opacity: 0.5 
                       });
                   }
               });
            });

            hand.add(model);
            scene.add(hand);
            return hand;
        }

        handLeft = createHand(0);  // å·¦æ‰‹
        handRight = createHand(1); // å³æ‰‹

        renderer.setAnimationLoop(render);
    }

    // --- 3. 3D UI ç”Ÿæˆå™¨ ---
    function createPowerTag(position) {
        if (powerSprite) scene.remove(powerSprite);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        powerSprite = new THREE.Sprite(material);

        // è®¾ç½®å¤§å° (å®½1ç±³, é«˜0.5ç±³)
        powerSprite.scale.set(1.0, 0.5, 1);
        // ä½ç½®è®¾ç½®åœ¨ç‚¹å‡»ç‚¹ä¸Šæ–¹ 0.5ç±³ (æ¨¡æ‹Ÿå¤´é¡¶)
        powerSprite.position.copy(position).add(new THREE.Vector3(0, 0.5, 0));

        scene.add(powerSprite);
        return { texture, sprite: powerSprite };
    }

    function drawCanvas(text, subtext, isFinal = false) {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = "rgba(0, 30, 0, 0.6)"; // åŠé€æ˜é»‘ç»¿åº•
        ctx.fillRect(0, 0, 512, 256);

        // è¾¹æ¡†
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 5;
        ctx.strokeRect(0, 0, 512, 256);

        // æ–‡å­—
        ctx.textAlign = "center";

        // æˆ˜æ–—åŠ›æ•°å€¼
        ctx.font = "bold 120px Courier New";
        ctx.fillStyle = isFinal && parseInt(text) > 8000 ? "#ff3333" : "#00ff00";
        ctx.fillText(text, 256, 150);

        // å‰¯æ ‡é¢˜
        ctx.font = "30px Courier New";
        ctx.fillStyle = "#00ff00";
        ctx.fillText(subtext, 256, 220);
    }

    // --- 4. æ‰‹åŠ¿åˆ¤å®šé€»è¾‘ ---

    // åˆ¤å®šå³æ‰‹æŒ‡å‘ï¼šé£ŸæŒ‡ä¼¸ç›´ï¼Œä¸­æŒ‡å¼¯æ›²
    function isPointing(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;

        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;

        // è®¡ç®—è·ç¦»
        const dIndex = wrist.distanceTo(indexTip);
        const dMiddle = wrist.distanceTo(middleTip);

        // é˜ˆå€¼ï¼šé£ŸæŒ‡é•¿åº¦é€šå¸¸ > 10cm, å¼¯æ›²åä¸­æŒ‡ < 10cm
        // æ ¸å¿ƒæ¡ä»¶ï¼šé£ŸæŒ‡æ˜æ˜¾æ¯”ä¸­æŒ‡é•¿ (ä¼¸å‡ºå»äº†)
        return dIndex > 0.10 && dMiddle < 0.10 && (dIndex > dMiddle + 0.03); 
    }

    // åˆ¤å®šå·¦æ‰‹æ¡æ‹³ï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½ç¦»æ‰‹è…•å¾ˆè¿‘
    function isFist(hand) {
        if (!hand || !hand.joints || !hand.joints['wrist']) return false;

        const wrist = hand.joints['wrist'].position;
        const indexTip = hand.joints['index-finger-tip'].position;
        const middleTip = hand.joints['middle-finger-tip'].position;
        const ringTip = hand.joints['ring-finger-tip'].position;

        const dIndex = wrist.distanceTo(indexTip);
        const dMiddle = wrist.distanceTo(middleTip);
        const dRing = wrist.distanceTo(ringTip);

        // å¦‚æœä¸‰ä¸ªä¸»è¦æ‰‹æŒ‡éƒ½å·æ›² (è·ç¦»æ‰‹è…• < 9cm)
        return dIndex < 0.09 && dMiddle < 0.09 && dRing < 0.09;
    }

    // --- 5. äº¤äº’æµç¨‹ ---
    function triggerScan(pos) {
        if (isLocked) return;
        isLocked = true;

        // åœ¨å¤´é¡¶ç”Ÿæˆ UI
        const { texture } = createPowerTag(pos);

        document.getElementById('hud-status').innerText = "TARGET LOCKED.";

        // åŠ¨ç”»é€»è¾‘
        let steps = 0;
        const targetVal = Math.floor(Math.random() * 9000) + 1000;

        scanInterval = setInterval(() => {
            steps++;
            const randomVal = Math.floor(Math.random() * 9999);

            drawCanvas(randomVal, "CALCULATING...", false);
            texture.needsUpdate = true; // å¿…é¡»è®¾ç½®ï¼Œå¦åˆ™è´´å›¾ä¸æ›´æ–°

            if (steps > 30) {
                clearInterval(scanInterval);
                const isHigh = targetVal > 8000;
                drawCanvas(targetVal, isHigh ? "IT'S OVER 9000!" : "POWER LEVEL", true);
                texture.needsUpdate = true;
            }
        }, 50);
    }

    function resetSystem() {
        if (!isLocked) return;

        isLocked = false;
        clearInterval(scanInterval);
        if (powerSprite) {
            scene.remove(powerSprite);
            powerSprite = null;
        }
        document.getElementById('hud-status').innerText = "READY. POINT TO SCAN.";
    }

    // --- 6. æ¸²æŸ“å¾ªç¯ ---
    function render(timestamp, frame) {
        if (frame) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();

            // Hit Test (ç„å‡†)
            if (hitTestSourceRequested === false) {
                session.requestReferenceSpace('viewer').then((refSpace) => {
                    session.requestHitTestSource({ space: refSpace }).then((source) => {
                        hitTestSource = source;
                    });
                });
                session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                hitTestSourceRequested = true;
            }

            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);

                // åªæœ‰åœ¨æ²¡é”å®šçš„æƒ…å†µä¸‹æ‰æ›´æ–°å…‰æ ‡
                if (!isLocked && hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                } else {
                    reticle.visible = false;
                }
            }

            // æ‰‹åŠ¿ç›‘å¬
            // 1. å³æ‰‹æŒ‡å‘ -> è§¦å‘
            if (!isLocked && reticle.visible && isPointing(handRight)) {
                const targetPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                triggerScan(targetPos);
            }

            // 2. å·¦æ‰‹æ¡æ‹³ -> å¤ä½
            if (isLocked && isFist(handLeft)) {
                resetSystem();
            }
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
        // 1. æ£€æµ‹æ‰‹åŠ¿
        let gesture = 'neutral';
        const g1 = getGesture(hand1);
        const g2 = getGesture(hand2);
        if (g1 !== 'neutral' && g1 !== 'none') gesture = g1;
        else if (g2 !== 'neutral' && g2 !== 'none') gesture = g2;

        // 2. ç²’å­åŠ¨ç”»é€»è¾‘
        const positions = particleGeo.attributes.position.array;

        // ç›®æ ‡é¢œè‰² (ç”¨äºæ•´ä¸ªç²’å­å›¢å˜è‰²)
        let targetR=0, targetG=0, targetB=0; 
        // è¿™é‡Œåªæ˜¯ç®€å•çš„é€»è¾‘ï¼Œå¦‚æœè¦æ”¹å•ä¸ªç²’å­é¢œè‰²éœ€è¦æ“ä½œ color bufferï¼Œä¸ºæ€§èƒ½è€ƒè™‘æš‚ä¸”åªæ”¹å½¢æ€

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const ox = originalPositions[i].x;
            const oy = originalPositions[i].y;
            const oz = originalPositions[i].z;

            // --- å‘¼å¸æ•ˆæœ (Idle Animation) ---
            // è®©ç²’å­åœ¨åŸä½é™„è¿‘åšæ­£å¼¦æ³¢è¿åŠ¨
            const drift = Math.sin(time * 1.5 + randomOffsets[i]) * 0.02;

            let tx, ty, tz;

            if (gesture === 'palm') {
                // ğŸ’¥ çƒŸèŠ±æ¨¡å¼ï¼šå‘å¤–çˆ†ç‚¸ï¼Œå¹¶åŠ ä¸Šå¼ºçƒˆçš„éšæœºæŠ–åŠ¨
                // é¢œè‰²æˆ‘ä»¬é€šè¿‡ material.color å…¨å±€å åŠ 
                tx = ox * 3.5 + drift;
                ty = oy * 3.5 + drift;
                tz = oz * 3.5 + drift;
            } else if (gesture === 'fist') {
                // ğŸ›‘ èšåˆæ¨¡å¼ï¼šå¼ºåŠ›å‹ç¼©åˆ°ä¸­å¿ƒ
                tx = ox * 0.1;
                ty = oy * 0.1;
                tz = oz * 0.1;
            } else {
                // ğŸŒŠ é»˜è®¤æ¨¡å¼ï¼šå¤åŸ + å‘¼å¸
                tx = ox + drift;
                ty = oy + drift;
                tz = oz + drift;
            }

            // å¹³æ»‘æ’å€¼ (Lerp) - è®©è¿åŠ¨æœ‰â€œé˜»å°¼æ„Ÿâ€ï¼Œè€Œä¸æ˜¯ç¬é—´è·³å˜
            // 0.1 æ˜¯å¹³æ»‘ç³»æ•°ï¼Œè¶Šå°è¶Šæ…¢
            positions[ix]   += (tx - positions[ix]) * 0.08;
            positions[ix+1] += (ty - positions[ix+1]) * 0.08;
            positions[ix+2] += (tz - positions[ix+2]) * 0.08;
        }

        // å…¨å±€é¢œè‰²ä¿®æ­£
        if (gesture === 'palm') {
            particleSystem.material.color.setHex(0xffaa00); // æš–é‡‘
            particleSystem.material.opacity = 1.0;
        } else if (gesture === 'fist') {
            particleSystem.material.color.setHex(0xff0055); // ç‚½çº¢
            particleSystem.material.opacity = 0.8;
        } else {
            particleSystem.material.color.setHex(0xffffff); // æ¢å¤åŸæœ¬çš„è“ç´«æ¸å˜
            particleSystem.material.opacity = 0.9;
        }

        particleGeo.attributes.position.needsUpdate = true;

        // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªèˆå°ï¼Œå¢åŠ ç©ºé—´æ„Ÿ
        stage.rotation.y += 0.002;

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
